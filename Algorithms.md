# Algorithms<br/>
> Алгоритм - набор инструкций для выполнения задачи

## Бинарный поиск<br/>
Алгоритм на входе получает отсортированный список<br/>
Проверяем базу в середине и узнаем попали/совпадение с референсом (если попали, то получаем индекс объекта). Если не попали, проверяем в какую половину двигаться поиском дальше<br/>
Проверяем оставшийся кусок в середине, узнаем в какую половину от этой половины двигаться и так далее до определения<br/>

В случае загаданного числа от 1 до 100:<br/>
Бинарный поиск максимум - 7 шагов<br/>
Простой поиск максимум - 100 шагов<br/>

Для списка из n элементов, бинарный поиск выполняется за log<sub>2</sub>n шагов, а обычный поиск за n шагов<br/>

> Логарифм - операция обратная возведению в степень<br/>
> log<sub>10</sub>10000 = 4<br/>
> log<sub>2</sub>16 = 4<br/>
> log без указания степени по умолчанию log<sub>2</sub><br/>

### Время выполнения<br/>
В простом поиске время *линейное*<br/>
> O(n)<br/>

В бинарном поиске время *логарифмическое*<br/>
> O(Log n)<br/>

Время выполнения разных алгоритмов растет с разной скоростью относительно ** возрастания объема данных**. Оптимальные алгоритмы могут все больше и больше возрастать в эффективности относительно неоптимальных с увеличением количества данных<br/>

О-большое опысывает насколько быстро работает алгоритм, на сколько быстро возрастает время выполнения алгоритма и определяет время выполнения в предельном случае(если придется выполнить все операции) и дает гаранитии в том, что алгоритм никогда не будет работать медленнее, чем описывает О-большое<br/>

не сравнивается время, сравнивается предельное количество операций алгоритма<br/>

### Время выполнения(от быстрого до медленного)<br/>
O(log n) - логарифмическое время (пример: бинарный поиск)<br/>
O(n) - линейное время (пример: простой поиск)<br/>
O(n * log n) - быстрая сортировка<br/>
O(n<sup>2</sup>) - медленная сортировка, сортировка выбором<br/>
O(n!) - факториальное время (n! - n-факториал) очень медленные алгоритмы (задача коммивояжера)<br/>

> Время алгоритма = рост потенциально максимального количества требуемых операций (при возрастании входящих данных для обработки этим алгоритмом)
<br/>
<br/>

## Сортировка выбором (Selection Sort)
### Связанные списки или массивы
**Массивы** в основном занимают конкретное слитное место в памяти. Например, массив из 4 объектов займет ячейки с 0 до 3. Но если массив расширится, то ему придется перемещаться в памяти, чтобы можно было найти единый кусок для своей расширенной версии и всем этим данным нужно будет переместиться туда. Это затратная операция.  
Если заранее выдать этому массиву до 10 ячеек, это может помочь ситуации, но память часто будет использоваться неэффективно, часть ячеек будет простаивать. При этом, если объектов станет 11, то все равно массив ждет затратный переезд.  
То есть массивы лучше для поиска по ним, а не для активного пополнения, заполнения. 

> [!TIP]
>Скорее всего, этот способ можно модифицировать имея сторонний механизм, когда в определенное время дня массив обновляется и сортируется, а в остальное время связанный список собирает данные.
>В таком случае общая система сможет делать бинарный быстрый поиск по отсортированному огромному массиву, и если данные не найдены, то потом идти в маленький динамический связанный список и медленно, но на гораздо меньшем объеме данных проводить дополнительный поиск. Большой шанс что данные уже есть в большом массиве, и, предположительно, часто до медленного поиска может не доходить.