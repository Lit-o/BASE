# Algorithms<br/>
> Алгоритм - набор инструкций для выполнения задачи

## Бинарный поиск<br/>
Алгоритм на входе получает отсортированный список<br/>
Проверяем базу в середине и узнаем попали/совпадение с референсом (если попали, то получаем индекс объекта). Если не попали, проверяем в какую половину двигаться поиском дальше<br/>
Проверяем оставшийся кусок в середине, узнаем в какую половину от этой половины двигаться и так далее до определения<br/>

В случае загаданного числа от 1 до 100:<br/>
Бинарный поиск максимум - 7 шагов<br/>
Простой поиск максимум - 100 шагов<br/>

Для списка из n элементов, бинарный поиск выполняется за log<sub>2</sub>n шагов, а обычный поиск за n шагов<br/>

> Логарифм - операция обратная возведению в степень<br/>
> log<sub>10</sub>10000 = 4<br/>
> log<sub>2</sub>16 = 4<br/>
> log без указания степени по умолчанию log<sub>2</sub><br/>

### Время выполнения<br/>
В простом поиске время *линейное*<br/>
> O(n)<br/>

В бинарном поиске время *логарифмическое*<br/>
> O(Log n)<br/>

Время выполнения разных алгоритмов растет с разной скоростью относительно ** возрастания объема данных**. Оптимальные алгоритмы могут все больше и больше возрастать в эффективности относительно неоптимальных с увеличением количества данных<br/>

О-большое опысывает насколько быстро работает алгоритм, на сколько быстро возрастает время выполнения алгоритма и определяет время выполнения в предельном случае(если придется выполнить все операции) и дает гаранитии в том, что алгоритм никогда не будет работать медленнее, чем описывает О-большое<br/>

не сравнивается время, сравнивается предельное количество операций алгоритма<br/>

### Время выполнения(от быстрого до медленного)<br/>
O(log n) - логарифмическое время (пример: бинарный поиск)<br/>
O(n) - линейное время (пример: простой поиск)<br/>
O(n * log n) - быстрая сортировка<br/>
O(n<sup>2</sup>) - медленная сортировка, сортировка выбором<br/>
O(n!) - факториальное время (n! - n-факториал) очень медленные алгоритмы (задача коммивояжера)<br/>

> Время алгоритма = рост потенциально максимального количества требуемых операций (при возрастании входящих данных для обработки этим алгоритмом)
<br/>
<br/>

## Сортировка выбором (Selection Sort)
### Массивы (Arrays) 
#### Скорость массива - Чтение О(1), Вставка О(n), Удаление O(n)
Массивы в основном занимают конкретное слитное место в памяти. Например, массив из 4 объектов займет ячейки с 0 до 3. Но если массив расширится, то ему придется перемещаться в памяти, чтобы можно было найти единый кусок для своей расширенной версии и всем этим данным нужно будет переместиться туда. Это затратная операция.  
Если заранее выдать этому массиву до 10 ячеек, это может помочь ситуации, но память часто будет использоваться неэффективно, часть ячеек будет простаивать. При этом, если объектов станет 11, то все равно массив ждет затратный переезд.  
То есть массивы лучше для поиска по ним, а не для активного пополнения, заполнения, ведь после вставки массив придется еще и отсортировать. 
Сильная сторона массивов - поиск или точечный доступ. Мгновенное чтение элемента из произвольной позиции, и обращаться к конкретному элементу можно моментально (массивы нумеруются с 0, позиции в массиве называются индексом)

> [!TIP]
>Скорее всего, этот способ можно модифицировать имея сторонний механизм, когда в определенное время дня массив обновляется и сортируется, а в остальное время связанный список собирает данные.
>В таком случае общая система сможет делать бинарный быстрый поиск по отсортированному огромному массиву, и если данные не найдены, то потом идти в маленький динамический связанный список и медленно, но на гораздо меньшем объеме данных проводить дополнительный поиск. Большой шанс что данные уже есть в большом массиве, и, предположительно, часто до медленного поиска может не доходить.
<br/>

### Связанные списки (Linked list)
#### Скорость связанного списка - Чтение О(n), Вставка О(1), Удаление O(1)

В связанном списке элементы данных могут размещаться в памяти где угодно. 
В каждом элементе (выделяется небольшой кусочек памяти в котором) хранится адрес следующей ячейки памяти(ставится метка, направление, ***указатель*** на следующий элемент списка). 
Набор рандомных адресов связывается этими ***указателями*** в цепочку.
Благодаря этому добавлять новые элементы в связанный список просто. Новые данные размещаются в любом свободном месте памяти и говорят свой адрес прошлому элементу, а предыдущий элемент этот адрес у себя сохраняет.
В отличие от **массивов** связанные списки хорошо дополняются, но тяжело читаются. Например, чтобы обратиться к 62му элементу, нужно будет от первого элемента 61 раз пройтись по 61 адресу, чтобы предпоследний элемент указал  наконец искомое фактическое место в пямяти, куда мне нужно.
<br/>

> Я не знаю изначально по какому фактическому адресу в памяти хранится нужная мне информация. Каждая ячейка знает только следующую, а я знаю только сколько мне раз нужно спросить. Если моя задача и подразумевает читать все элементы данных подряд (например вывести все позиции покупок на экран), то и хорошо, когда задачей подразумевается в любом случае прочитать все элементы списка - связанный список нормально подойдет. Но если мне нужно быстро точечно находить конкретное в порядке определенным конкретным случаем - будет медленно. 

> [!NOTE]
> Массивы или Списки?
> Массивы работают быстрее, так как в том числе компьютером может использоваться кеширование и комп может считывать за итерацию блоки данных. Со списком так не получится, итерация = шаг к следующему элементу. 
> На массивы для их ускорения выделяют кусочки дополнительной памяти, которая в основном эффективно используется, это нагрузка на память. Но и в связанных списках есть лишнаяя нагрузка на память, потому что каждый элемент должен забрать себе кусочек памяти, где будет хранить адрес следующего элемента. И если сам этот элемент не велик, то может оказаться так, что сама информация о следующей ячейке занимает столько же памяти, сколько полезная информация ячейки. 
> В целом, массивы используют чаще. Связанные списки больше для особых случаев.

> [!NOTE]
> А вообще можно сделать гибрид - массив связанных списков или еще как-нибудь. В конце концов массивы и связанные списки становятся структурными элементами сложных систем баз данных.
